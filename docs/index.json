[
  {
    "description": "inherits from the base model",
    "tags": [
      {
        "title": "name",
        "name": "agol"
      }
    ],
    "loc": {
      "start": {
        "line": 9,
        "column": 2
      },
      "end": {
        "line": 11,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 12,
          "column": 2
        },
        "end": {
          "line": 15,
          "column": 2
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
      "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
      "path": "models/agol.js",
      "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L12-L15"
    },
    "name": "agol",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Add pages of requests through the throttle Q",
          "tags": [
            {
              "title": "param",
              "description": "the total number of features in the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "count"
            },
            {
              "title": "param",
              "description": "an array of page urls to be requested",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "pageRequests"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "the item json metadata from the server",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the numeric id of the layer being requested",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "layerId"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "name",
              "name": "_page"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 727,
              "column": 2
            },
            "end": {
              "line": 736,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 737,
                "column": 2
              },
              "end": {
                "line": 799,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L737-L799"
          },
          "params": [
            {
              "title": "param",
              "description": "the total number of features in the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "count"
            },
            {
              "title": "param",
              "description": "an array of page urls to be requested",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "pageRequests"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "the item json metadata from the server",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the numeric id of the layer being requested",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "layerId"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            }
          ],
          "name": "_page",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "_page"
          ]
        },
        {
          "description": "Method to remove all the data in each export dir\nthis logic is being used in 4 places",
          "tags": [
            {
              "title": "param",
              "description": "The base dir to remove all files",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dir"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "_removeExportDirs"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 169,
              "column": 2
            },
            "end": {
              "line": 174,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 175,
                "column": 2
              },
              "end": {
                "line": 194,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L175-L194"
          },
          "params": [
            {
              "title": "param",
              "description": "The base dir to remove all files",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "dir"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "_removeExportDirs",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "_removeExportDirs"
          ]
        },
        {
          "description": "A queue used to throttle requests\nwe need this to prevent duplicate paging requests that\ncause features to be inserted twice",
          "tags": [
            {
              "title": "name",
              "name": "_throttleQ"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 704,
              "column": 2
            },
            "end": {
              "line": 708,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 709,
                "column": 2
              },
              "end": {
                "line": 737,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L709-L737"
          },
          "name": "_throttleQ",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "_throttleQ"
          ]
        },
        {
          "description": "Puts the dataset into a state of processes\nmakes async call to create the geohash\nsaves the geohash agg into the file given",
          "tags": [
            {
              "title": "param",
              "description": "request params from the url",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "the path of the file to be saved",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "filePath"
            },
            {
              "title": "param",
              "description": "the name of the file to save, determined by request params",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "fileName"
            },
            {
              "title": "param",
              "description": "optional params from the url querystring",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "buildGeohash"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 993,
              "column": 2
            },
            "end": {
              "line": 1002,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 1003,
                "column": 2
              },
              "end": {
                "line": 1044,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L1003-L1044"
          },
          "params": [
            {
              "title": "param",
              "description": "request params from the url",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "the path of the file to be saved",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "filePath"
            },
            {
              "title": "param",
              "description": "the name of the file to save, determined by request params",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "fileName"
            },
            {
              "title": "param",
              "description": "optional params from the url querystring",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "buildGeohash",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "buildGeohash"
          ]
        },
        {
          "description": "A queue used to control the flow of the csv inserts\nif we get many requests for a new CSV they insert multiple times\nhere we handle removing the data cache before we insert",
          "tags": [
            {
              "title": "name",
              "name": "csvQueue"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 368,
              "column": 2
            },
            "end": {
              "line": 372,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 373,
                "column": 2
              },
              "end": {
                "line": 439,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L373-L439"
          },
          "name": "csvQueue",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "csvQueue"
          ]
        },
        {
          "description": "Drops the item from the cache\nwill remove all exported files as well,\nbut will only remove \"latest\" files if forceDelete is set",
          "tags": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "dropItem"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 115,
              "column": 2
            },
            "end": {
              "line": 123,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 124,
                "column": 2
              },
              "end": {
                "line": 175,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L124-L175"
          },
          "params": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "dropItem",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "dropItem"
          ]
        },
        {
          "description": "Makes a request to the feature service\nfirst checks the count and determines if koop should make one or many requests",
          "tags": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "featureServiceRequest"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 619,
              "column": 2
            },
            "end": {
              "line": 628,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 629,
                "column": 2
              },
              "end": {
                "line": 670,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L629-L670"
          },
          "params": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "featureServiceRequest",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "featureServiceRequest"
          ]
        },
        {
          "description": "Get a service by id\nif no id given then return all services",
          "tags": [
            {
              "title": "param",
              "description": "the id used to reference this host in the db",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "find"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 84,
              "column": 2
            },
            "end": {
              "line": 89,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 90,
                "column": 2
              },
              "end": {
                "line": 106,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L90-L106"
          },
          "params": [
            {
              "title": "param",
              "description": "the id used to reference this host in the db",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "find",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "find"
          ]
        },
        {
          "description": "Mapping between Esri geomTypes and GeoJSON types",
          "tags": [
            {
              "title": "name",
              "name": "geomTypes"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 796,
              "column": 2
            },
            "end": {
              "line": 798,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 799,
                "column": 2
              },
              "end": {
                "line": 813,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L799-L813"
          },
          "name": "geomTypes",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "geomTypes"
          ]
        },
        {
          "description": "Get the count of the features in the cache\nwrapper around the Cache.getCount method",
          "tags": [
            {
              "title": "param",
              "description": "a table name in the db",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getCount"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 236,
              "column": 2
            },
            "end": {
              "line": 242,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 243,
                "column": 2
              },
              "end": {
                "line": 252,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L243-L252"
          },
          "params": [
            {
              "title": "param",
              "description": "a table name in the db",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getCount",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getCount"
          ]
        },
        {
          "description": "Gets CSV item data from the server and inserts it into the Cache",
          "tags": [
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "baseUrl"
            },
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getCSV"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 430,
              "column": 2
            },
            "end": {
              "line": 438,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 439,
                "column": 2
              },
              "end": {
                "line": 496,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L439-L496"
          },
          "params": [
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "baseUrl"
            },
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getCSV",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getCSV"
          ]
        },
        {
          "description": "This is really the main entry point to this model\nhere we route to the correct data type method based on the item type",
          "tags": [
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "the id of the host in the DB",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "option"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getData"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 341,
              "column": 2
            },
            "end": {
              "line": 351,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 352,
                "column": 2
              },
              "end": {
                "line": 373,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L352-L373"
          },
          "params": [
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "the id of the host in the DB",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "option"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getData",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getData"
          ]
        },
        {
          "description": "Determines if the FeatureService is already cached or not",
          "tags": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getDataFromCache"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 567,
              "column": 2
            },
            "end": {
              "line": 575,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 576,
                "column": 2
              },
              "end": {
                "line": 615,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L576-L615"
          },
          "params": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getDataFromCache",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getDataFromCache"
          ]
        },
        {
          "description": "Get a feature collection from the server and inserts it\nFeatureCollection are simply JSON features requested in one just (not services)",
          "tags": [
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "baseUrl"
            },
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getFeatureCollection"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 486,
              "column": 2
            },
            "end": {
              "line": 495,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 496,
                "column": 2
              },
              "end": {
                "line": 547,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L496-L547"
          },
          "params": [
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "baseUrl"
            },
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getFeatureCollection",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getFeatureCollection"
          ]
        },
        {
          "description": "Gets the service metadata first and adds any fields to request for the actual features",
          "tags": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getFeatureService"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 538,
              "column": 2
            },
            "end": {
              "line": 546,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 547,
                "column": 2
              },
              "end": {
                "line": 576,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L547-L576"
          },
          "params": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "json metadata from the item in the host",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "itemJson"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getFeatureService",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getFeatureService"
          ]
        },
        {
          "description": "Gets the feature service info",
          "tags": [
            {
              "title": "param",
              "description": "the max number of features in the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "the id of the service layer",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "layer"
            },
            {
              "title": "param",
              "description": "called when the service info comes back",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getFeatureServiceLayerInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 925,
              "column": 2
            },
            "end": {
              "line": 930,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 931,
                "column": 2
              },
              "end": {
                "line": 948,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L931-L948"
          },
          "params": [
            {
              "title": "param",
              "description": "the max number of features in the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "the id of the service layer",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "layer"
            },
            {
              "title": "param",
              "description": "called when the service info comes back",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getFeatureServiceLayerInfo",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getFeatureServiceLayerInfo"
          ]
        },
        {
          "description": "Wraps Cache.getInfo to make testing possible w/o the cache",
          "tags": [
            {
              "title": "param",
              "description": "a table name in the db",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getInfo"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 247,
              "column": 2
            },
            "end": {
              "line": 251,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 252,
                "column": 2
              },
              "end": {
                "line": 265,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L252-L265"
          },
          "params": [
            {
              "title": "param",
              "description": "a table name in the db",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "key"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getInfo",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getInfo"
          ]
        },
        {
          "description": "Get the service then get the item",
          "tags": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getItem"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 187,
              "column": 2
            },
            "end": {
              "line": 193,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 194,
                "column": 2
              },
              "end": {
                "line": 225,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L194-L225"
          },
          "params": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getItem",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getItem"
          ]
        },
        {
          "description": "Get the actual features and metadata from the DB",
          "tags": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "the id of the host in the DB",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getItemData"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 256,
              "column": 2
            },
            "end": {
              "line": 264,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 265,
                "column": 2
              },
              "end": {
                "line": 352,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L265-L352"
          },
          "params": [
            {
              "title": "param",
              "description": "the host is needed to tell what dataset to remove",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "the id of the host in the DB",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hostId"
            },
            {
              "title": "param",
              "description": "id of the item",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "itemid"
            },
            {
              "title": "param",
              "description": "the sha1 hash of the params and querystring",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "hash"
            },
            {
              "title": "param",
              "description": "optional params from req.query (the querystring)",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getItemData",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getItemData"
          ]
        },
        {
          "description": "Get an item's metadata\nrequests the metadata and attachs it to an object before calling the callback",
          "tags": [
            {
              "title": "param",
              "description": "the agol deploy to get data from",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "the agol item id",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "item"
            },
            {
              "title": "param",
              "description": "an item's json data to attach metadata to",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "json"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getItemMetadata"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 216,
              "column": 2
            },
            "end": {
              "line": 224,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 225,
                "column": 2
              },
              "end": {
                "line": 243,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L225-L243"
          },
          "params": [
            {
              "title": "param",
              "description": "the agol deploy to get data from",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "the agol item id",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "item"
            },
            {
              "title": "param",
              "description": "an item's json data to attach metadata to",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "json"
            },
            {
              "title": "param",
              "description": "the callback for when all is gone",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getItemMetadata",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getItemMetadata"
          ]
        },
        {
          "description": "Find and return the OID field from the list of fields on metadata",
          "tags": [
            {
              "title": "param",
              "description": "metadata from the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "info"
            },
            {
              "title": "name",
              "name": "getObjectIDField"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 944,
              "column": 2
            },
            "end": {
              "line": 947,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 948,
                "column": 2
              },
              "end": {
                "line": 962,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L948-L962"
          },
          "params": [
            {
              "title": "param",
              "description": "metadata from the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "info"
            }
          ],
          "name": "getObjectIDField",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getObjectIDField"
          ]
        },
        {
          "description": "Returns the count of jobs on each Kue queue",
          "tags": [
            {
              "title": "param",
              "description": "a function to call when all counts have returns",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "getQueueCounts"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 958,
              "column": 2
            },
            "end": {
              "line": 961,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 962,
                "column": 2
              },
              "end": {
                "line": 1003,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L962-L1003"
          },
          "params": [
            {
              "title": "param",
              "description": "a function to call when all counts have returns",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "getQueueCounts",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "getQueueCounts"
          ]
        },
        {
          "description": "Checks to see if an item is expired or not",
          "tags": [
            {
              "title": "param",
              "description": "metadata from the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "info"
            },
            {
              "title": "param",
              "description": "the number of the layer in the request",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "layerId"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "isExpired"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 1038,
              "column": 2
            },
            "end": {
              "line": 1043,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 1044,
                "column": 2
              },
              "end": {
                "line": 1077,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L1044-L1077"
          },
          "params": [
            {
              "title": "param",
              "description": "metadata from the service",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "info"
            },
            {
              "title": "param",
              "description": "the number of the layer in the request",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "number"
              },
              "name": "layerId"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "isExpired",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "isExpired"
          ]
        },
        {
          "description": "Adds a service to the Cache\nneeds a host, generates an id",
          "tags": [
            {
              "title": "param",
              "description": "the id used to reference this host in the db",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "host to request items from",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "register"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 59,
              "column": 2
            },
            "end": {
              "line": 66,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 67,
                "column": 2
              },
              "end": {
                "line": 80,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L67-L80"
          },
          "params": [
            {
              "title": "param",
              "description": "the id used to reference this host in the db",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "host to request items from",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "register",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "register"
          ]
        },
        {
          "description": "Adds a service to the Cache\nneeds a host, generates an id",
          "tags": [
            {
              "title": "param",
              "description": "the id used to reference this host in the db",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "host to request items from",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "remove"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 73,
              "column": 2
            },
            "end": {
              "line": 79,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 80,
                "column": 2
              },
              "end": {
                "line": 90,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L80-L90"
          },
          "params": [
            {
              "title": "param",
              "description": "the id used to reference this host in the db",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "id"
            },
            {
              "title": "param",
              "description": "host to request items from",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "host"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "remove",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "remove"
          ]
        },
        {
          "description": "Centralized request method that forces URI encoding\nall ajax requests should use this so it can be tested",
          "tags": [
            {
              "title": "param",
              "description": "The url for the request.",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "req"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 100,
              "column": 2
            },
            "end": {
              "line": 105,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 106,
                "column": 2
              },
              "end": {
                "line": 124,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L106-L124"
          },
          "params": [
            {
              "title": "param",
              "description": "The url for the request.",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "The callback.",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "req",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "req"
          ]
        },
        {
          "description": "Make requests for feature pages\nexecute done when we have all features",
          "tags": [
            {
              "title": "param",
              "description": "an array of pare URLs to request",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "array"
              },
              "name": "pages"
            },
            {
              "title": "param",
              "description": "service params",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "optional params for creating pages",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "done"
            },
            {
              "title": "name",
              "name": "requestQueue"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 805,
              "column": 2
            },
            "end": {
              "line": 812,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 813,
                "column": 2
              },
              "end": {
                "line": 859,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L813-L859"
          },
          "params": [
            {
              "title": "param",
              "description": "an array of pare URLs to request",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "array"
              },
              "name": "pages"
            },
            {
              "title": "param",
              "description": "service params",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "optional params for creating pages",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "done"
            }
          ],
          "name": "requestQueue",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "requestQueue"
          ]
        },
        {
          "description": "Create a worker job that will handle the requests",
          "tags": [
            {
              "title": "param",
              "description": "an array of pare URLs to request",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "array"
              },
              "name": "pages"
            },
            {
              "title": "param",
              "description": "service params",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "optional params for creating pages",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "done"
            },
            {
              "title": "name",
              "name": "sendToWorkers"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 851,
              "column": 2
            },
            "end": {
              "line": 858,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 859,
                "column": 2
              },
              "end": {
                "line": 931,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L859-L931"
          },
          "params": [
            {
              "title": "param",
              "description": "an array of pare URLs to request",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "array"
              },
              "name": "pages"
            },
            {
              "title": "param",
              "description": "service params",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "optional params for creating pages",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": "callback to call when the requests are done",
              "lineNumber": 6,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "done"
            }
          ],
          "name": "sendToWorkers",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "sendToWorkers"
          ]
        },
        {
          "description": "Removes the layer from the end of a url",
          "tags": [
            {
              "title": "param",
              "description": "the url to strip the layer from",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "length of the layer value to string",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "length"
            },
            {
              "title": "name",
              "name": "stripLayerOffUrl"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "agol"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 610,
              "column": 2
            },
            "end": {
              "line": 614,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 615,
                "column": 2
              },
              "end": {
                "line": 629,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/agol.js",
            "code": "{\n  /** \n   * inherits from the base model \n   */\n  var agol = new koop.BaseModel(koop)\n\n  // base path to use for every host\n  agol.agol_path = '/sharing/rest/content/items/'\n\n  // how to long to persist the cache of data\n  // after which data will be dropped and re-fetched\n  // epoch = days * hours * minutes * secs * millisecs\n  agol.cacheLife = (24 * 60 * 60 * 1000)\n\n  // Request Worker Config\n  // create a request queue if configured to page large data sets to workers\n  if (koop.config.agol && koop.config.agol.request_workers) {\n    agol.worker_q = kue.createQueue({\n      prefix: koop.config.agol.request_workers.redis.prefix || 'q',\n      disableSearch: true,\n      redis: {\n        port: koop.config.agol.request_workers.redis.port || 6379,\n        host: koop.config.agol.request_workers.redis.host || '127.0.0.1'\n      }\n    })\n\n    // remove completed jobs from the queue\n    agol.worker_q.on('job complete', function (id) {\n      kue.Job.get(id, function (err, job) {\n        if (err) return\n        job.remove(function (err) {\n          if (err) {\n            agol.log('debug', 'could not remove completed job #' + job.id)\n          }\n          agol.log('debug', 'removed completed job #' + job.id + ' - ' + id)\n        })\n      })\n    })\n\n    // track and log job progress, just handy to have\n    agol.worker_q.on('job progress', function (id, progress) {\n      agol.log('debug', 'progress ' + id + ' - ' + progress + '%')\n    })\n\n  }\n\n  // check to see if koop is configured to force workers on all data\n  if (koop.config.export_workers && koop.config.export_workers.force) {\n    agol.forceExportWorker = true\n  }\n\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   *\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.register = function (id, host, callback) {\n    var type = 'agol:services'\n    koop.Cache.serviceRegister(type, {'id': id, 'host': host}, callback)\n  }\n\n  // removes the registered host from the list of hosts\n  /**\n   * Adds a service to the Cache\n   * needs a host, generates an id\n   * @param {string} id - the id used to reference this host in the db\n   * @param {string} host - host to request items from\n   * @param {function} callback - The callback.\n   */\n  agol.remove = function (id, callback) {\n    koop.Cache.db.serviceRemove('agol:services', parseInt(id, 0) || id, callback)\n  }\n\n  /**\n   * Get a service by id\n   * if no id given then return all services\n   * @param {string} id - the id used to reference this host in the db\n   * @param {function} callback - The callback.\n   */\n  agol.find = function (id, callback) {\n    koop.Cache.db.serviceGet('agol:services', parseInt(id, 0) || id, function (err, res) {\n      if (err) {\n        callback('No service table found for that id. Try POSTing {\"id\":\"arcgis\", \"host\":\"http://www.arcgis.com\"} to /agol', null)\n      } else {\n        callback(null, res)\n      }\n    })\n  }\n\n  /**\n   * Centralized request method that forces URI encoding\n   * all ajax requests should use this so it can be tested\n   * @param {string} url - The url for the request.\n   * @param {function} callback - The callback.\n   */\n  agol.req = function (url, callback) {\n    // force hosted service requests to use ssl\n    url = utils.forceHttps(url)\n    request({\n      url: encodeURI(decodeURI(url)),\n      headers: { 'User-Agent': 'esri-koop' }\n    }, callback)\n  }\n\n  /**\n   * Drops the item from the cache\n   * will remove all exported files as well,\n   * but will only remove \"latest\" files if forceDelete is set\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.dropItem = function (host, itemId, options, callback) {\n    var layerId = (options.layer || 0)\n\n    if (koop.Exporter.export_q) {\n      var jobData = {\n        itemId: itemId,\n        layerId: layerId,\n        remove: true\n      }\n\n      // add the job to the distributed worker pool\n      var job = koop.Exporter.export_q.create('exports', jobData).save(function (err) {\n        if (err) {\n          return callback(err)\n        }\n        agol.log('debug', 'added a remove job to the export_q' + job.id)\n        var dir = [ itemId, layerId ].join('_')\n        koop.Cache.remove('agol', itemId, options, function (err, res) {\n          if (err) {\n            return callback(err)\n          }\n          agol._removeExportDirs(dir, function (err, success) {\n            if (options.forceDelete) {\n              koop.files.removeDir('latest/files/' + dir, function (err, res) {\n                callback(err, true)\n              })\n            } else {\n              callback(err, true)\n            }\n          })\n        })\n      })\n\n    } else {\n      var dir = [ itemId, layerId ].join('_')\n      koop.Cache.remove('agol', itemId, options, function (err, res) {\n        if (err) {\n          return callback(err)\n        }\n        agol._removeExportDirs(dir, callback)\n      })\n\n    }\n  }\n\n  /**\n   * Method to remove all the data in each export dir\n   * this logic is being used in 4 places\n   * @param {string} dir - The base dir to remove all files\n   * @param {function} callback - The callback.\n   */\n  agol._removeExportDirs = function (dir, callback) {\n    var dirs = ['files/', 'tiles/', 'thumbs/']\n\n    async.each(dirs, function (base, callback) {\n      koop.files.removeDir(base + dir, function (err) {\n        callback(err)\n      })\n    }, function (err) {\n      callback(err)\n    })\n  }\n\n  /**\n   * Get the service then get the item\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getItem = function (host, itemId, options, callback) {\n    var url = host + this.agol_path + itemId + '?f=json'\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n      try {\n        var json = JSON.parse(data.body)\n        if (json.error) {\n          return callback(json.error.message, null)\n        }\n        if (options.getMetadata && json.typeKeywords && json.typeKeywords.indexOf('Metadata') !== -1) {\n          agol.getItemMetadata(host, itemId, json, callback)\n        } else {\n          callback(null, json)\n        }\n      } catch (e) {\n        callback('Problem accessing the request host', null)\n      }\n    })\n  }\n\n  /**\n  * Get an item's metadata\n  * requests the metadata and attachs it to an object before calling the callback\n  *\n  * @param {string} host - the agol deploy to get data from\n  * @param {string} item - the agol item id\n  * @param {object} json - an item's json data to attach metadata to\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemMetadata = function (host, item, json, callback) {\n    var url = [host, this.agol_path, item, '/info/metadata/metadata.xml?format=default'].join('')\n    this.req(url, function (err, data) {\n      if (err) {\n        return callback(err)\n      }\n      json.metadata = data.body\n      callback(null, json)\n    })\n  }\n\n  /**\n   * Get the count of the features in the cache\n   * wrapper around the Cache.getCount method\n   * @param {string} key - a table name in the db\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getCount = function (key, options, callback) {\n    koop.Cache.getCount(key, options, callback)\n  }\n\n  /**\n   * Wraps Cache.getInfo to make testing possible w/o the cache\n   * @param {string} key - a table name in the db\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getInfo = function (key, callback) {\n    koop.Cache.getInfo(key, callback)\n  }\n\n  /**\n  * Get the actual features and metadata from the DB\n  * @param {string} host - the host is needed to tell what dataset to remove\n  * @param {string} hostId - the id of the host in the DB\n  * @param {string} itemid - id of the item\n  * @param {string} hash - the sha1 hash of the params and querystring\n  * @param {object} options - optional params from req.query (the querystring)\n  * @param {function} callback - the callback for when all is gone\n  */\n  agol.getItemData = function (host, hostId, itemId, hash, options, callback) {\n    var self = this\n    this.getItem(host, itemId, options, function (err, itemJson) {\n      var layerId = options.layer || 0\n      if (err) {\n        return callback(err, null)\n      }\n\n      // put host in option so our cacheCheck has ref to it\n      options.host = host\n\n      var qKey = ['agol', itemId, layerId].join(':')\n\n      self.getInfo(qKey, function (err, info) {\n        if (err) {\n          return callback(err)\n        }\n        var is_expired = info ? (Date.now() >= info.expires_at) : false\n\n        // check the last char on the url\n        // protects us from urls registered with layers already in the url\n        if (itemJson && itemJson.url) {\n          var layer = itemJson.url.split('/').pop()\n          if (parseInt(layer, 0) >= 0) {\n            var len = ('' + layer).length\n            itemJson.hasLayerURL = true\n            itemJson.url = itemJson.url.substring(0, itemJson.url.length - ((len || 2) + 1))\n          }\n        }\n\n        // Note: we have to check the service metadata to know if the item has changed in AGOL\n        self.getFeatureServiceLayerInfo(itemJson.url, (options.layer || 0), function (err, serviceInfo) {\n          if (err) {\n            return callback(err)\n          }\n          // TODO centralize this logic\n          // check for infon on last edit date\n          // set is_expired to false if it hasnt changed\n          if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n            if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > itemJson.modified)) {\n              is_expired = false\n            } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n              is_expired = true\n            } else {\n              // if the retrieved at date is greater than the lastEditDate then the data are still good\n              is_expired = false\n            }\n          }\n\n          var params = {\n            itemJson: itemJson,\n            serviceInfo: serviceInfo,\n            host: host,\n            hostId: hostId,\n            itemId: itemId,\n            layerId: layerId,\n            hash: hash\n          }\n\n          if (!is_expired) {\n            return self.getData(params, options, callback)\n          }\n\n          koop.Cache.remove('agol', itemId, options, function (err, res) {\n            if (err) {\n              return callback(err)\n            }\n            self.getData(params, options, callback)\n          })\n        })\n\n      })\n\n    })\n  }\n\n  /**\n   * This is really the main entry point to this model\n   * here we route to the correct data type method based on the item type\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} host - the host is needed to tell what dataset to remove\n   * @param {string} itemid - id of the item\n   * @param {string} hostId - the id of the host in the DB\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {option} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n   */\n  agol.getData = function (params, options, callback) {\n    if (params.itemJson.type === 'CSV') {\n      return agol.getCSV(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Collection') {\n      return agol.getFeatureCollection(params.host + agol.agol_path, params, options, callback)\n    }\n\n    if (params.itemJson.type === 'Feature Service' || params.itemJson.type === 'Map Service') {\n      return agol.getFeatureService(params, options, callback)\n    }\n\n    return callback('item must be a Feature Collection, Feature Service, or CSV')\n  }\n\n  /**\n   * A queue used to control the flow of the csv inserts\n   * if we get many requests for a new CSV they insert multiple times\n   * here we handle removing the data cache before we insert\n  */\n  agol.csvQueue = async.queue(function (task, cb) {\n    agol.req(task.url, function (err, data) {\n      if (err) {\n        return task.callback(err, null)\n      }\n\n      csv.parse(data.body, function (err, csv_data) {\n        if (err) {\n          task.callback({ code: 400, error: 'Trouble parsing the CSV data'}, null)\n          return cb()\n        }\n        koop.GeoJSON.fromCSV(csv_data, function (err, geojson) {\n          if (err) {\n            return task.callback(err)\n          }\n          // store metadata with the data\n          var json = {}\n          json.name = task.itemJson.name || task.itemJson.title\n          json.updated_at = task.itemJson.modified\n          json.expires_at = task.expires_at\n          json.retrieved_at = Date.now()\n          json.info = { name: json.name, fields: csv_data[0]}\n          json.host = {\n            id: task.hostId\n          }\n          json.features = []\n\n          var dir = [ task.id, (task.options.layer || 0) ].join('_')\n          koop.Cache.remove('agol', task.id, task.options, function (err, res) {\n            if (err) return task.callback(err)\n            agol._removeExportDirs(dir, function (err, res) {\n              if (err) return task.callback(err)\n              koop.Cache.insert('agol', task.id, json, (task.options.layer || 0), function (err, success) {\n                if (!err && res) {\n                  koop.Cache.insertPartial('agol', task.id, geojson, (task.options.layer || 0), function (err, success) {\n                    if (success) {\n                      task.itemJson.data = [geojson]\n                      task.callback(null, task.itemJson)\n                    } else {\n                      task.callback(err, null)\n                    }\n                    cb()\n                  })\n                } else {\n                  // the table create failed which is fine, just do nothing\n                  task.itemJson.data = [geojson]\n                  task.callback(null, task.itemJson)\n                  cb()\n                }\n              })\n            })\n          })\n        })\n      })\n    })\n  }, 1)\n\n  /**\n   * Gets CSV item data from the server and inserts it into the Cache\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getCSV = function (baseUrl, params, options, callback) {\n    var self = this\n    var task = {}\n    var id = params.id\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    var qKey = ['agol', id, params.layerId].join(':')\n\n    var maxSize = 5000000\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.getInfo(qKey, function (err, info) {\n      if (err) return callback(err)\n      koop.Cache.get('agol', id, options, function (err, entry) {\n        if (err || (info && info.retrieved_at < itemJson.modified)) {\n          if (itemJson.size < maxSize) {\n            // replace .csv in name\n            itemJson.name = itemJson.name.replace('.csv', '')\n\n            task.url = baseUrl + '/' + id + '/data?f=json'\n            task.itemJson = itemJson\n            task.id = id\n            task.hostId = hostId\n            task.options = options\n            task.expires_at = Date.now() + self.cacheLife\n            task.callback = callback\n            self.csvQueue.push(task, function () {})\n          } else {\n            callback({ code: 413, error: 'The requested CSV exceeds the allowable size of ' + maxSize + ' bytes' }, null)\n          }\n        } else {\n          if (entry && entry[0] && entry[0].exceeds_limit) {\n            itemJson.data = entry\n            itemJson.koop_status = 'too big'\n            callback(null, itemJson)\n          } else {\n            itemJson.data = entry\n            callback(null, itemJson)\n          }\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a feature collection from the server and inserts it\n   * FeatureCollection are simply JSON features requested in one just (not services)\n   * @param {string} baseUrl - id of the item\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureCollection = function (baseUrl, params, options, callback) {\n    var id = params.itemId\n    var itemJson = params.itemJson\n    var hostId = params.hostId\n\n    // for large datasets enforce koop's large data limit\n    options.enforce_limit = true\n\n    koop.Cache.get('agol', id, options, function (err, entry) {\n      if (!err) {\n        itemJson.data = entry\n        return callback(null, itemJson)\n      }\n\n      var url = baseUrl + '/' + id + '/data?f=json'\n      agol.req(url, function (err, data) {\n        if (err) {\n          return callback(err, null)\n        }\n\n        var json = JSON.parse(data.body).featureCollection.layers[0].featureSet\n        koop.GeoJSON.fromEsri([], json, function (err, geojson) {\n          if (err) return callback(err)\n          geojson.name = itemJson.name || itemJson.title\n          geojson.updated_at = itemJson.modified\n          geojson.host = {\n            id: hostId\n          }\n          koop.Cache.insert('agol', id, geojson, params.layerId, function (err, success) {\n            if (success) {\n              itemJson.data = [geojson]\n              callback(null, itemJson)\n            } else {\n              callback(err, null)\n            }\n          })\n        })\n      })\n\n    })\n  }\n\n  /**\n   * Gets the service metadata first and adds any fields to request for the actual features\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getFeatureService = function (params, options, callback) {\n    if (!params.itemJson.url) {\n      return callback('Missing url parameter for Feature Service Item')\n    }\n\n    // for large datasets enforce koop's large data limit\n    if (options.enforce_limit !== false) {\n      options.enforce_limit = true\n    }\n\n    // if our request has a where clause we need to search for Coded Values Domain\n    if (options && options.where) {\n      // add fields to options\n      options.fields = params.serviceInfo && params.serviceInfo.fields\n    }\n\n    // get data from cache\n    agol.getDataFromCache(params, options, callback)\n  }\n\n  /**\n   * Determines if the FeatureService is already cached or not\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.getDataFromCache = function (params, options, callback) {\n    var self = this\n    var itemJson = params.itemJson\n\n    // search the cache for this data\n    koop.Cache.get('agol', params.itemId, options, function (err, entry) {\n      if (err) {\n        // no data in the cache request new data\n        return self.featureServiceRequest(params, options, callback)\n      }\n\n      if (entry && entry[0] && entry[0].status === 'processing') {\n        itemJson.data = [{\n          features: [],\n          name: (itemJson.info) ? itemJson.info.name : itemJson.name,\n          geomType: self.geomTypes[itemJson.geometryType],\n          info: itemJson.info\n        }]\n        itemJson.koop_status = 'processing'\n        return callback(null, itemJson)\n      }\n\n      if (entry && entry[0] && entry[0].exceeds_limit) {\n        itemJson.data = entry\n        itemJson.koop_status = 'too big'\n        return callback(null, itemJson)\n      }\n\n      itemJson.data = entry\n      callback(null, itemJson)\n\n    })\n  }\n\n  /**\n   * Removes the layer from the end of a url\n   * @param {string} url - the url to strip the layer from\n   * @param {string} length - length of the layer value to string\n  */\n  agol.stripLayerOffUrl = function (url, len) {\n    return url.substring(0, url.length - ((len || 2) + 1))\n  }\n\n  /**\n   * Makes a request to the feature service\n   * first checks the count and determines if koop should make one or many requests\n   * @param {string} hostId - the host is needed to tell what dataset to remove\n   * @param {string} id - id of the item\n   * @param {object} itemJson - json metadata from the item in the host\n   * @param {string} hash - the sha1 hash of the params and querystring\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {function} callback - the callback for when all is gone\n  */\n  agol.featureServiceRequest = function (params, options, callback) {\n    var self = this\n\n    var layer = params.itemJson.url.split('/').pop()\n    if (parseInt(layer, 0) >= 0) {\n      params.itemJson.hasLayerURL = true\n    }\n\n    options = agol._normalizeOptions(params, options)\n\n    var info = {\n      status: 'processing',\n      updated_at: params.itemJson.modified,\n      expires_at: Date.now() + self.cacheLife,\n      retrieved_at: Date.now(),\n      name: options.name,\n      geomType: self.geomTypes[params.itemJson.geometryType],\n      info: params.serviceInfo || {},\n      features: [],\n      host: {\n        id: params.hostId\n      }\n    }\n\n    // save the fields as an array of the names\n    info.info.fields = (params.serviceInfo) ? params.serviceInfo.fields.map(function (f) { return f.name }) : []\n\n    koop.Cache.insert('agol', params.itemId, info, params.layerId, function (err) {\n      if (err) {\n        return callback(err)\n      }\n      // return in a processing state, but continue on\n      params.itemJson.data = [{ features: [] }]\n      params.itemJson.koop_status = 'processing'\n      params.itemJson.cache_save = false\n      params.itemJson.expires_at = info.expires_at\n\n      agol._page(params, options, callback)\n    })\n  }\n\n  agol._normalizeOptions = function (params, options) {\n    var itemJson = params.itemJson\n    var serviceInfo = params.serviceInfo\n\n    // set the name in options\n    if ((itemJson.name || itemJson.title) && !options.name) {\n      options.name = itemJson.name || itemJson.title\n    }\n\n    // sanitize any single quotes in the service description\n    if (serviceInfo) {\n      serviceInfo.description = serviceInfo.description && serviceInfo.description.replace(/'/g, '')\n      serviceInfo.definitionExpression = serviceInfo.definitionExpression && serviceInfo.definitionExpression.replace(/'/g, '')\n\n      if (serviceInfo.name && !params.itemJson.hasLayerURL) {\n        options.name = serviceInfo.name\n      } else if (serviceInfo.title) {\n        options.name = serviceInfo.title\n      }\n\n      // set the geom type\n      options.geomType = serviceInfo.geometryType\n      options.fields = serviceInfo.fields\n      options.objectIdField = agol.getObjectIDField(serviceInfo)\n    }\n\n    // sanitize the name...\n    options.name = options.name.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n    // fix long names; truncate to 150 chars\n    options.name = (options.name.length > 150) ? options.name.substr(0, 150) : options.name\n\n    return options\n  }\n\n  /**\n   * A queue used to throttle requests\n   * we need this to prevent duplicate paging requests that\n   * cause features to be inserted twice\n   */\n  agol._throttleQ = async.queue(function (key, cb) {\n    setTimeout(function () {\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          info = {}\n        }\n        if (!info.locked) {\n          info.locked = true\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            cb(err)\n          })\n        } else {\n          cb(info.locked)\n        }\n      })\n    }, Math.floor((Math.random() * 750) + 200))\n  }, 1)\n\n  /**\n   * Add pages of requests through the throttle Q\n   * @param {number} count - the total number of features in the service\n   * @param {string} pageRequests - an array of page urls to be requested\n   * @param {string} id - id of the item\n   * @param {object} itemJson - the item json metadata from the server\n   * @param {number} layerId - the numeric id of the layer being requested\n   * @param {object} options - optional params from req.query (the querystring)\n   * @param {string} hash - the sha1 hash of the params and querystring\n  */\n  agol._page = function (params, options, callback) {\n    params.featureService = new FeatureService(utils.forceHttps(params.itemJson.url), options)\n    params.featureService.pages(function (err, pages) {\n      if (err) {\n        return callback(err)\n      }\n\n      // add to a separate queue that we can use to add jobs one at a time\n      // this prevents the case when we get 2 requests at the same time\n      if (pages.length > 1) {\n        callback(null, params.itemJson)\n      }\n\n      var key = ['agol', params.itemId, params.layerId].join(':')\n      agol._throttleQ.push(key, function (locked) {\n        if (!locked) {\n          if (koop.config.agol && koop.config.agol.request_workers) {\n            return agol.sendToWorkers(pages, params, options)\n          }\n\n          agol.requestQueue(pages, params, options, function (error, data) {\n            koop.Cache.getInfo(key, function (err, info) {\n              if (err || !info) {\n                info = {}\n              }\n              if (error) {\n                var errJson\n                try {\n                  errJson = JSON.parse(error)\n                } catch (e) {\n                  errJson = {response: error}\n                }\n                info.paging_failed = {error: errJson}\n                info.generating = {\n                  error: {\n                    code: errJson.code,\n                    request: errJson.request,\n                    response: errJson.response,\n                    message: 'Failed to cache the data'\n                  }\n                }\n              } else {\n                // remove status info: means the job is done (is good...)\n                delete info.status\n              }\n\n              koop.Cache.updateInfo(key, info, function () {\n                if (pages.length === 1) {\n                  params.itemJson.data = [data]\n                  callback(null, params.itemJson)\n                }\n              })\n            })\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Mapping between Esri geomTypes and GeoJSON types\n   */\n  agol.geomTypes = {\n    'esriGeometryPolygon': 'Polygon',\n    'esriGeometryPoint': 'Point',\n    'esriGeometryPolyLine': 'LineString'\n  }\n\n  /**\n   * Make requests for feature pages\n   * execute done when we have all features\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.requestQueue = function (pages, params, options, done) {\n    var reqCount = 0\n    // setup the place to collect all the features\n    var itemJson = params.itemJson\n    itemJson.data = [{ features: [] }]\n\n    // aggregate responses into one json and call done we have all of them\n    var collect = function (error, json) {\n      if (error) {\n        params.featureService.pageQueue.kill()\n        return done(error || 'Feature page JSON is undefined')\n      }\n\n      if (json) {\n        if (json.error) {\n          params.featureService.pageQueue.kill()\n          return done(json.error.details[0])\n        }\n\n        // insert a partial\n        koop.GeoJSON.fromEsri(options.fields || [], json, function (err, geojson) {\n          if (err) return done(err)\n          // concat the features so we return the full json\n          koop.Cache.insertPartial('agol', params.itemId, geojson, params.layerId, function (err) {\n            if (err) return done(err)\n            if (reqCount++ === pages.length - 1) {\n              // pass back the full array of features\n              done(null, itemJson)\n            }\n          })\n        })\n      }\n    }\n\n    agol.log('info', params.itemId + ' # of requests:' + pages.length)\n    params.featureService.pageQueue.push(pages, collect)\n  }\n\n  /**\n   * Create a worker job that will handle the requests\n   *\n   * @param {array} pages - an array of pare URLs to request\n   * @param {object} params - service params\n   * @param {object} options - optional params for creating pages\n   * @param {function} done - callback to call when the requests are done\n   */\n  agol.sendToWorkers = function (pages, params, options) {\n    var jobData = {\n      serviceUrl: params.itemJson.url,\n      itemId: params.itemId,\n      layerId: params.layerId,\n      pages: pages,\n      fields: options.fields || []\n    }\n\n    // info key - used to look item info in the cache\n    var key = ['agol', params.itemId, params.layerId].join(':')\n\n    // add the job to the distributed worker pool\n    var job = agol.worker_q.create('agol', jobData).save(function (err) {\n      agol.log('debug', 'added page requests to job-queue ' + job.id, err)\n    })\n\n    var removeJob = function (job) {\n      job.remove(function (err) {\n        if (err) {\n          agol.log('debug', 'could not remove failed job #' + job.id + ' Error: ' + err)\n          return\n        }\n        agol.log('debug', 'removed failed request job #' + job.id + ' - ' + params.itemId)\n      })\n    }\n\n    // track failed jobs and flag them\n    job.on('failed', function (jobErr) {\n      agol.log('error', 'Request worker job failed ' + jobErr)\n\n      koop.Cache.getInfo(key, function (err, info) {\n        if (err || !info) {\n          return removeJob(job)\n        }\n\n        kue.Job.get(job.id, function (err, job) {\n          if (err) agol.log('error', 'Could not get job from queue ' + err)\n          var errJson\n          try {\n            errJson = JSON.parse(job._error)\n            info.paging_failed = {error: errJson}\n          } catch (e) {\n            errJson = {response: job._error}\n          }\n          info.paging_failed = {error: errJson}\n          info.generating = {\n            error: {\n              code: errJson.code,\n              request: errJson.request,\n              response: errJson.response,\n              message: 'Failed to cache the data'\n            }\n          }\n          koop.Cache.updateInfo(key, info, function (err, success) {\n            if (err) {\n              return\n            }\n            removeJob(job)\n          })\n        })\n      })\n    })\n\n  }\n\n  /**\n   * Gets the feature service info\n   * @param {string} url - the max number of features in the service\n   * @param {number} layer - the id of the service layer\n   * @param {function} callback - called when the service info comes back\n   */\n  agol.getFeatureServiceLayerInfo = function (url, layer, callback) {\n    url = url + '/' + layer + '?f=json'\n    agol.req(url, function (err, res) {\n      try {\n        var json = JSON.parse(res.body)\n        json.url = url\n        callback(err, json)\n      } catch (e) {\n        callback('failed to parse service info')\n      }\n    })\n  }\n\n  /**\n   * Find and return the OID field from the list of fields on metadata\n   * @param {object} info - metadata from the service\n   */\n  agol.getObjectIDField = function (info) {\n    var field\n    info.fields.forEach(function (f, i) {\n      if (f.type === 'esriFieldTypeOID') {\n        field = f.name\n      }\n    })\n    return field\n  }\n\n  /**\n   * Returns the count of jobs on each Kue queue\n   * @param {function} callback - a function to call when all counts have returns\n   */\n  agol.getQueueCounts = function (callback) {\n    var response = {}\n    var error\n    var count = 0\n    var jobTypes = ['inactiveCount', 'activeCount', 'completeCount', 'failedCount', 'delayedCount']\n    // for (var type in jobTypes){\n    function getJobCounts (type) {\n      koop.collectQStats(agol.worker_q, response, type, function (err, json) {\n        count++\n        if (err) {\n          error = err\n        }\n        // save the response\n        response = json\n\n        // get more if there are more types\n        if (jobTypes[count]) {\n          getJobCounts(jobTypes[count])\n        } else {\n          // return the response\n          if (error) {\n            callback(error)\n          } else {\n            callback(null, response)\n          }\n        }\n      })\n    }\n    getJobCounts(jobTypes[count])\n  }\n\n  /**\n   * Puts the dataset into a state of processes\n   * makes async call to create the geohash\n   * saves the geohash agg into the file given\n   * @param {string} params - request params from the url\n   * @param {string} filePath - the path of the file to be saved\n   * @param {string} fileName - the name of the file to save, determined by request params\n   * @param {object} options - optional params from the url querystring\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.buildGeohash = function (params, filePath, fileName, options, callback) {\n    var key = [ 'agol', params.item, params.layer ].join(':')\n\n    agol.getInfo(key, function (err, info) {\n      if (err) return callback(err)\n      // put the dataset into a state of process via update info\n      info.geohashStatus = 'processing'\n      koop.Cache.updateInfo(key, info, function (err, success) {\n        if (err) return callback(err)\n        // trigger the callback right away so we can return 202 until it done\n        // if we dont have a where filter then we return with processes (async)\n        if (!options.where) {\n          callback()\n        }\n        // get the geohash page from the DB\n        agol.getGeoHash(key, options, function (err, agg) {\n          if (err) return callback(err)\n          // save the file\n          agol.saveFile(filePath, fileName, JSON.stringify(agg), function (err) {\n            if (err) return callback(err)\n            // remove status processing\n            delete info.geohashStatus\n            koop.Cache.updateInfo(key, info, function (err, success) {\n              if (err) return callback(err)\n              // if we DO have a where filter then we can return the agg right away\n              if (options.where) {\n                callback(null, agg)\n              }\n            })\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * Checks to see if an item is expired or not\n   * @param {object} info - metadata from the service\n   * @param {number} layerId - the number of the layer in the request\n   * @param {function} callback - callback to call when the requests are done\n   */\n  agol.isExpired = function (info, layerId, callback) {\n    var isExpired = info ? (new Date().getTime() >= info.expires_at) : false\n\n    if (info && info.info && info.info.url) {\n      // clean up the url; remove layer at the end just in case\n      var url = info.info.url.replace('?f=json', '')\n      var layer = url.split('/').pop()\n      if (parseInt(layer, 0) >= 0) {\n        var len = ('' + layer).length\n        url = url.substring(0, url.length - ((len || 2) + 1))\n      }\n\n      agol.getFeatureServiceLayerInfo(url, layerId, function (err, serviceInfo) {\n        if (err) return callback(err)\n        // check for info on last edit date (for hosted services dont expired unless changed)\n        // set isExpired to false if it hasnt changed or if its null\n        if (info && info.retrieved_at && serviceInfo && serviceInfo.editingInfo) {\n          if (!serviceInfo.editingInfo.lastEditDate && (info.retrieved_at > info.info.modified)) {\n            isExpired = false\n          } else if (info.retrieved_at < serviceInfo.editingInfo.lastEditDate) {\n            isExpired = true\n          } else {\n            // if the retrieved at date is greater than the lastEditDate then the data are still good\n            isExpired = false\n          }\n        }\n        callback(null, isExpired)\n      })\n    } else {\n      callback(null, isExpired)\n    }\n  }\n\n  return agol\n}",
            "path": "models/agol.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/agol.js#L615-L629"
          },
          "params": [
            {
              "title": "param",
              "description": "the url to strip the layer from",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "url"
            },
            {
              "title": "param",
              "description": "length of the layer value to string",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "string"
              },
              "name": "length"
            }
          ],
          "name": "stripLayerOffUrl",
          "kind": "function",
          "memberof": "agol",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "agol",
            "stripLayerOffUrl"
          ]
        }
      ]
    },
    "events": [],
    "path": [
      "agol"
    ]
  },
  {
    "description": "The primary controller onto which all methods are attached",
    "tags": [
      {
        "title": "name",
        "name": "controller"
      }
    ],
    "loc": {
      "start": {
        "line": 14,
        "column": 2
      },
      "end": {
        "line": 16,
        "column": 5
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 17,
          "column": 2
        },
        "end": {
          "line": 26,
          "column": 2
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
      "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
      "path": "controller/index.js",
      "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L17-L26"
    },
    "name": "controller",
    "members": {
      "instance": [],
      "static": [
        {
          "description": "Creates a unique based on request params and the querystring",
          "tags": [
            {
              "title": "returns",
              "description": "key",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              }
            },
            {
              "title": "name",
              "name": "_createCacheKey"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 197,
              "column": 2
            },
            "end": {
              "line": 200,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 201,
                "column": 2
              },
              "end": {
                "line": 226,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L201-L226"
          },
          "returns": [
            {
              "title": "returns",
              "description": "key",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "string"
              }
            }
          ],
          "name": "_createCacheKey",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "_createCacheKey"
          ]
        },
        {
          "description": "Exports a large dataset\ncalls the exportLarge method on the agol model",
          "tags": [
            {
              "title": "param",
              "description": "file export parameters",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "objects"
              },
              "name": "params"
            },
            {
              "title": "name",
              "name": "_exportLarge"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 524,
              "column": 2
            },
            "end": {
              "line": 528,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 529,
                "column": 2
              },
              "end": {
                "line": 596,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L529-L596"
          },
          "params": [
            {
              "title": "param",
              "description": "file export parameters",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "objects"
              },
              "name": "params"
            }
          ],
          "name": "_exportLarge",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "_exportLarge"
          ]
        },
        {
          "description": "Exports \"non-large\" data to a file format",
          "tags": [
            {
              "title": "param",
              "description": "file export parameters",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "objects"
              },
              "name": "params"
            },
            {
              "title": "name",
              "name": "_exportToFormat"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 592,
              "column": 2
            },
            "end": {
              "line": 595,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 596,
                "column": 2
              },
              "end": {
                "line": 649,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L596-L649"
          },
          "params": [
            {
              "title": "param",
              "description": "file export parameters",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "objects"
              },
              "name": "params"
            }
          ],
          "name": "_exportToFormat",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "_exportToFormat"
          ]
        },
        {
          "description": "Gets the actual json data from the model",
          "tags": [
            {
              "title": "param",
              "description": "required params used to fetch data",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "optional query string based params",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": null,
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            },
            {
              "title": "name",
              "name": "_getItemData"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 142,
              "column": 2
            },
            "end": {
              "line": 148,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 149,
                "column": 2
              },
              "end": {
                "line": 201,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L149-L201"
          },
          "params": [
            {
              "title": "param",
              "description": "required params used to fetch data",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "params"
            },
            {
              "title": "param",
              "description": "optional query string based params",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "options"
            },
            {
              "title": "param",
              "description": null,
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "function"
              },
              "name": "callback"
            }
          ],
          "name": "_getItemData",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "_getItemData"
          ]
        },
        {
          "description": "Set file download headers for data exports\nadds the content-disposition and content-type bases on the file format",
          "tags": [
            {
              "title": "params",
              "description": "{object} response object",
              "lineNumber": 4
            },
            {
              "title": "params",
              "description": "{string} name - the name of the file",
              "lineNumber": 5
            },
            {
              "title": "params",
              "description": "{string} format - the exported file format",
              "lineNumber": 6
            },
            {
              "title": "returns",
              "description": "response",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            },
            {
              "title": "name",
              "name": "_setHeaders"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 676,
              "column": 2
            },
            "end": {
              "line": 684,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 685,
                "column": 2
              },
              "end": {
                "line": 708,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L685-L708"
          },
          "returns": [
            {
              "title": "returns",
              "description": "response",
              "lineNumber": 7,
              "type": {
                "type": "NameExpression",
                "name": "object"
              }
            }
          ],
          "name": "_setHeaders",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "_setHeaders"
          ]
        },
        {
          "description": "handles a DELETE to remove a registered host from the DB",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "del"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 39,
              "column": 2
            },
            "end": {
              "line": 44,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 45,
                "column": 2
              },
              "end": {
                "line": 64,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L45-L64"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "del",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "del"
          ]
        },
        {
          "description": "Forced a drop of the cache for an item and DELETEs all known files\nused for responding to DELETE calls.",
          "tags": [
            {
              "title": "name",
              "name": "deleteItemData"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 971,
              "column": 2
            },
            "end": {
              "line": 974,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 975,
                "column": 2
              },
              "end": {
                "line": 984,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L975-L984"
          },
          "name": "deleteItemData",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "deleteItemData"
          ]
        },
        {
          "description": "Drops the cache for an item",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "dropItem"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 116,
              "column": 2
            },
            "end": {
              "line": 120,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 121,
                "column": 2
              },
              "end": {
                "line": 149,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L121-L149"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "dropItem",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "dropItem"
          ]
        },
        {
          "description": "Handles all requests for FeatureServices",
          "tags": [
            {
              "title": "name",
              "name": "featureserver"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 705,
              "column": 2
            },
            "end": {
              "line": 707,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 708,
                "column": 2
              },
              "end": {
                "line": 766,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L708-L766"
          },
          "name": "featureserver",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "featureserver"
          ]
        },
        {
          "description": "",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "find"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 74,
              "column": 2
            },
            "end": {
              "line": 78,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 79,
                "column": 2
              },
              "end": {
                "line": 94,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L79-L94"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "find",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "find"
          ]
        },
        {
          "description": "",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "findItem"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 89,
              "column": 2
            },
            "end": {
              "line": 93,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 94,
                "column": 2
              },
              "end": {
                "line": 121,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L94-L121"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "findItem",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "findItem"
          ]
        },
        {
          "description": "Finds the item's data\nthis method is crux of the controller. It handles the logic for returning data in several forms:\n  - status processing return 202\n  - status is processing but a file exists\n  - a file exists for the data\n  - a new file needs to be created\n  - no format given, just returns json",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "findItemData"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 215,
              "column": 2
            },
            "end": {
              "line": 225,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 226,
                "column": 2
              },
              "end": {
                "line": 370,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L226-L370"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 8,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 9,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "findItemData",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "findItemData"
          ]
        },
        {
          "description": "Get the geohash for an item/layer",
          "tags": [
            {
              "title": "name",
              "name": "getGeohash"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 993,
              "column": 2
            },
            "end": {
              "line": 997,
              "column": 4
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 998,
                "column": 2
              },
              "end": {
                "line": 1067,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L998-L1067"
          },
          "name": "getGeohash",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "getGeohash"
          ]
        },
        {
          "description": "Request handler for returning the counts of currently queued workers",
          "tags": [
            {
              "title": "name",
              "name": "getQueueCounts"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 980,
              "column": 2
            },
            "end": {
              "line": 983,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 984,
                "column": 2
              },
              "end": {
                "line": 998,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L984-L998"
          },
          "name": "getQueueCounts",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "getQueueCounts"
          ]
        },
        {
          "description": "",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "list"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 59,
              "column": 2
            },
            "end": {
              "line": 63,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 64,
                "column": 2
              },
              "end": {
                "line": 79,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L64-L79"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 2,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 3,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "list",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "list"
          ]
        },
        {
          "description": "renders the preview map view",
          "tags": [
            {
              "title": "name",
              "name": "preview"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 833,
              "column": 2
            },
            "end": {
              "line": 835,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 836,
                "column": 2
              },
              "end": {
                "line": 845,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L836-L845"
          },
          "name": "preview",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "preview"
          ]
        },
        {
          "description": "Registers a host with the given id\nthis inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com",
          "tags": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            },
            {
              "title": "name",
              "name": "register"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 19,
              "column": 2
            },
            "end": {
              "line": 25,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 26,
                "column": 2
              },
              "end": {
                "line": 45,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L26-L45"
          },
          "params": [
            {
              "title": "param",
              "description": "the incoming request object",
              "lineNumber": 4,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "req"
            },
            {
              "title": "param",
              "description": "the outgoing response object",
              "lineNumber": 5,
              "type": {
                "type": "NameExpression",
                "name": "object"
              },
              "name": "res"
            }
          ],
          "name": "register",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "register"
          ]
        },
        {
          "description": "Handles request for thubmnails",
          "tags": [
            {
              "title": "name",
              "name": "thumbnail"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 763,
              "column": 2
            },
            "end": {
              "line": 765,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 766,
                "column": 2
              },
              "end": {
                "line": 836,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L766-L836"
          },
          "name": "thumbnail",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "thumbnail"
          ]
        },
        {
          "description": "Tile request handler, responds to z/x/y tile requests",
          "tags": [
            {
              "title": "name",
              "name": "tiles"
            },
            {
              "title": "kind",
              "kind": "function"
            },
            {
              "title": "memberof",
              "description": "controller"
            },
            {
              "title": "static"
            }
          ],
          "loc": {
            "start": {
              "line": 841,
              "column": 2
            },
            "end": {
              "line": 844,
              "column": 5
            }
          },
          "context": {
            "loc": {
              "start": {
                "line": 845,
                "column": 2
              },
              "end": {
                "line": 975,
                "column": 2
              }
            },
            "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
            "code": "{\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}",
            "path": "controller/index.js",
            "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L845-L975"
          },
          "name": "tiles",
          "kind": "function",
          "memberof": "controller",
          "scope": "static",
          "members": {
            "instance": [],
            "static": []
          },
          "events": [],
          "path": [
            "controller",
            "tiles"
          ]
        }
      ]
    },
    "events": [],
    "path": [
      "controller"
    ]
  },
  {
    "description": "Inherit from the koop base controller\nhandles requests for routes",
    "tags": [
      {
        "title": "module",
        "description": null,
        "lineNumber": 3,
        "type": null,
        "name": "Controller"
      },
      {
        "title": "name",
        "name": "Controller"
      },
      {
        "title": "kind",
        "kind": "module"
      }
    ],
    "loc": {
      "start": {
        "line": 8,
        "column": 0
      },
      "end": {
        "line": 12,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 13,
          "column": 0
        },
        "end": {
          "line": 1103,
          "column": 0
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/controller/index.js",
      "code": "var https = require('https')\nvar Sm = require('sphericalmercator')\nvar merc = new Sm({size: 256})\nvar crypto = require('crypto')\nvar _ = require('lodash')\nvar fs = require('fs')\n\n/**\n * Inherit from the koop base controller\n * handles requests for routes\n * @module Controller\n */\nvar Controller = function (agol, BaseController) {\n  /**\n   * The primary controller onto which all methods are attached\n   */\n  var controller = BaseController()\n\n  /**\n   * Registers a host with the given id\n   * this inserts a record into the db for an ArcGIS instances ie: id -> hostname :: arcgis -> arcgis.com\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.register = function (req, res) {\n    if (!req.body.host) {\n      return res.status(400).send('Must provide a host to register')\n    }\n\n    agol.register(req.body.id, req.body.host, function (err, id) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json({ 'serviceId': id })\n    })\n  }\n\n  /**\n   * handles a DELETE to remove a registered host from the DB\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.del = function (req, res) {\n    if (!req.params.id) {\n      return res.status(400).send('Must specify a service id')\n    }\n\n    agol.remove(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(400).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // returns a list of the registered hosts and thier ids\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.list = function (req, res) {\n    agol.find(null, function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // looks up a host based on a given id\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.find = function (req, res) {\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n      res.json(data)\n    })\n  }\n\n  // get the item metadata from the host\n  /**\n   *\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItem = function (req, res) {\n    if (req.params.format) {\n      return this.findItemData(req, res)\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.getItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(404).send(error)\n        }\n\n        res.contentType('text')\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Drops the cache for an item\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.dropItem = function (req, res) {\n    // if we have a layer then append it to the query params\n    if (req.params.layer) {\n      req.query.layer = req.params.layer\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(err.code || 404).send(err)\n      }\n\n      // Get the item\n      agol.dropItem(data.host, req.params.item, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 400).send(error)\n        }\n        res.json(itemJson)\n      })\n    })\n  }\n\n  /**\n   * Gets the actual json data from the model\n   *\n   * @param {object} params - required params used to fetch data\n   * @param {object} options - optional query string based params\n   * @param {function} callback\n   */\n  controller._getItemData = function (req, res, callback) {\n    var params = req.params\n    var options = req.query\n    var id = params.id\n    var item = params.item\n    var key = params.key\n\n    agol.find(id, function (err, data) {\n      if (err) {\n        return callback(err, null)\n      }\n\n      // Get the item\n      if (!parseInt(options.layer, 0)) {\n        options.layer = 0\n      }\n\n      agol.getItemData(data.host, id, item, key, options, function (error, itemJson) {\n        if (error) {\n          return callback(error, null)\n        }\n\n        if (itemJson.koop_status === 'processing' && typeof req.params.silent === 'undefined') {\n          // return w/202\n          agol.getCount(controller._createTableKey('agol', req.params), {}, function (err, count) {\n            var code = 202\n            var response = {\n              status: 'processing',\n              processing_time: (Date.now() - itemJson.retrieved_at) / 1000 || 0,\n              count: count\n            }\n            if (itemJson.generating) {\n              response.generating = itemJson.generating\n              // we received an error from the server\n              if (itemJson.generating.error || err) {\n                code = 502\n              }\n            }\n            res.status(code).json(response)\n          })\n          return\n        }\n\n        callback(null, itemJson)\n      })\n    })\n  }\n\n  /**\n   * Creates a unique based on request params and the querystring\n   * @returns {string} key\n   */\n  controller._createCacheKey = function (params, query) {\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(query).keys().sort().each(function (key) {\n      if (key !== 'url_only' && key !== 'format') {\n        sorted_query[key] = query[key]\n      }\n    })\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = params.item + '_' + (params.layer || 0) + JSON.stringify(sorted_query)\n\n    return crypto.createHash('md5').update(toHash).digest('hex')\n  }\n\n  /**\n   * Finds the item's data\n   * this method is crux of the controller. It handles the logic for returning data in several forms:\n   *   - status processing return 202\n   *   - status is processing but a file exists\n   *   - a file exists for the data\n   *   - a new file needs to be created\n   *   - no format given, just returns json\n   * @param {object} req - the incoming request object\n   * @param {object} res - the outgoing response object\n   */\n  controller.findItemData = function (req, res) {\n    var tableKey = controller._createTableKey('agol', req.params)\n    var dir = req.params.item + '_' + (req.params.layer || 0)\n    var path\n\n    // returns data in the data\n    agol.getInfo(tableKey, function (err, info) {\n      if (err) {\n        console.log(err)\n      }\n\n      // parse the spatial ref if we have one,\n      // if its whitelisted remove it from the query object\n      if (req.query.outSR) {\n        var sr = agol.parseSpatialReference(req.query.outSR)\n        if (sr && sr.wkid && [3785, 3857, 4326, 102100].indexOf(sr.wkid) !== -1) {\n          delete req.query.outSR\n        }\n      }\n\n      var key = controller._createCacheKey(req.params, req.query)\n      req.params.key = key\n\n      // determine if this request is for a filtered dataset\n      req.query.isFiltered = (req.query.where || req.query.geometry)\n\n      // if the status is processing we either return with a file or a 202\n      if (info && info.status === 'processing') {\n        if (req.params.format) {\n          return controller._returnProcessingFile(req, res, info)\n        }\n        return controller._returnProcessing(req, res, info)\n      }\n\n      // check format for exporting data\n      if (req.params.format) {\n        // file params for building an export file\n        var fileParams = {\n          req: req,\n          res: res,\n          dir: dir,\n          key: key,\n          format: req.params.format,\n          id: req.params.item,\n          type: 'agol'\n        }\n\n        // force an override on the format param if given a format in the query\n        if (req.query.format) {\n          req.params.format = req.query.format\n          delete req.query.format\n        }\n\n        // redirect to thumbnail for png access\n        if (req.params.format === 'png') {\n          return controller.thumbnail(req, res)\n        }\n\n        // create the file path\n        path = controller._createFilePath(key, req.params)\n        // the file name for the export\n        fileParams.fileName = controller._createName(info, key, req.params.format)\n        console.log()\n\n        // does the data export already exist?\n        agol.files.exists(path, fileParams.fileName, function (exists, path) {\n\n          // get the item data before we check for\n          agol.find(req.params.id, function (err, data) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n            // save the item layer\n            req.query.layer = (!parseInt(req.params.layer, 0)) ? 0 : req.params.layer\n\n            agol.getItem(data.host, req.params.item, req.query, function (err, itemJson) {\n              if (err) {\n                return res.status(500).send(err)\n              }\n\n              if (exists) {\n                return agol.isExpired(info, req.query.layer, function (err, isExpired) {\n                  fileParams.err = err\n                  if (!isExpired) {\n                    return controller._returnFile(req, res, path, fileParams.fileName)\n                  }\n\n                  // if it's expired, then remove the data and request a new file\n                  agol.dropItem(data.host, req.params.item, req.query, function () {\n                    req.query.format = req.params.format\n                    controller._getItemData(req, res, function (err, itemJson) {\n                      fileParams.err = err\n                      fileParams.itemJson = itemJson\n                      fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                      // var used to request new files if needed.\n                      controller._requestNewFile(fileParams)\n                    })\n                  })\n                })\n              }\n\n              req.query.format = req.params.format\n              controller._getItemData(req, res, function (err, itemJson) {\n                fileParams.err = err\n                fileParams.itemJson = itemJson\n                fileParams.data = (itemJson && itemJson.data && itemJson.data[0]) ? itemJson.data[0] : null\n                controller._requestNewFile(fileParams)\n              })\n            })\n          })\n        })\n      } else {\n        // if we have a layer then append it to the query params\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n        // get the esri json data for the service\n        controller._getItemData(req, res, function (err, itemJson) {\n          // when silent is sent as a param undefined\n          if (typeof req.params.silent === 'undefined') {\n            if (err) {\n              return res.status(err.code || 404).send(err.error || err)\n            }\n\n            // TODO remove hard coded maxRecCount\n            if (itemJson && itemJson.data && itemJson.data[0].features.length > 1000) {\n              itemJson.data[0].features = itemJson.data[0].features.splice(0, 1000)\n            }\n            return res.send(itemJson)\n          }\n        })\n      }\n    })\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createTableKey = function (type, params) {\n    return [type, params.item, (params.layer || 0)].join(':')\n  }\n\n  /**\n   * Respond to a request for file downloads when a dataset is still \"processing\"\n   * if the file exists send it, else return processing 202\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessingFile = function (req, res, info) {\n    // force an override on the format param if given a format in the query\n    delete req.query.format\n    // create the file path\n    var path = controller._createFilePath(req.params.key, req.params)\n    // get the name of the data; else use the key (md5 hash)\n    var fileName = controller._createName(info, req.params.key, req.params.format)\n\n    agol.files.exists(path, fileName, function (exists, path) {\n      if (exists) {\n        return controller._returnFile(req, res, path, fileName)\n      }\n      controller._returnProcessing(req, res, info)\n    })\n    return\n  }\n\n  /**\n   * Respond to a requests with a \"processing\" response\n   *\n   * @params {object} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   * @params {object} info - item metadata from the cache\n   * @private\n   */\n  controller._returnProcessing = function (req, res, info) {\n    var table = controller._createTableKey('agol', req.params)\n\n    if (typeof req.params.silent === 'undefined') {\n      agol.getCount(table, {}, function (err, count) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        var code = 202\n\n        // we need some logic around handling long standing processing times\n        var processingTime = (Date.now() - info.retrieved_at) / 1000 || 0\n\n        var response = {\n          status: 'processing',\n          processing_time: processingTime,\n          count: count\n        }\n        if (info.generating) {\n          response.generating = info.generating\n          if (info.generating.error) {\n            code = 502\n          }\n        }\n\n        agol.log('debug', JSON.stringify({status: code, item: req.params.item, layer: (req.params.layer || 0)}))\n        res.status(code).json(response)\n      })\n    }\n  }\n\n  /**\n   * Creates a clean and normalized name to be used in things like files on disk\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createName = function (info, key, format) {\n    format = format.replace('geojson', 'json')\n\n    var name = (info && info.info) ? info.name || info.info.name || info.info.title : key\n    name = (name.length > 150) ? name.substr(0, 150) : name\n\n    var fileName = name + '.' + format\n    fileName = fileName.replace(/\\/|,|&|\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)/g, '')\n\n    return fileName\n  }\n\n  /**\n   * Creates a clean file path for files exports\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._createFilePath = function (key, params) {\n    var dir = params.item + '_' + (params.layer || 0)\n    return ['files', dir, key].join('/')\n  }\n\n  /**\n   * Create key used to query a table in the cache\n   *\n   * @params {string} type - the type of the providers (\"agol\")\n   * @params {object} params - an object with an item id and layer number\n   *\n   * @returns {string} key\n   * @private\n   */\n  controller._requestNewFile = function (params) {\n    if (params.err) {\n      return res.status(params.err.code || 400).send(params.err.error || params.err)\n    }\n\n    var itemJson = params.itemJson\n    var res = params.res\n\n    // flatten the data from an array to sep objects/arrays\n    var itemData\n    var itemFeatures\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      itemData = itemJson.data[0]\n    }\n\n    if (itemData && itemData.features) {\n      itemFeatures = itemData.features\n    }\n\n    if (!itemFeatures || !itemFeatures.length) {\n      return res.status(404).send('No features exist for the requested FeatureService layer')\n    }\n\n    // this logic sure does suck...\n    var name = (itemJson && itemJson.data && itemJson.data[0] && (itemJson.data[0].name || (itemJson.data[0].info && itemJson.data[0].info.name))) ? itemJson.data[0].name || itemJson.data[0].info.name : itemJson.name || itemJson.title\n    // cleanze the name\n    name = name.replace(/\\/|,|&\\|/g, '').replace(/ /g, '_').replace(/\\(|\\)|\\$/g, '')\n    name = (name.length > 150) ? name.substr(0, 150) : name\n    params.name = name\n\n    if ((itemJson.koop_status && itemJson.koop_status === 'too big') || agol.forceExportWorker) {\n      return controller._exportLarge(params)\n    }\n\n    if (itemJson && itemJson.data && itemJson.data[0]) {\n      return controller._exportToFormat(params)\n    }\n\n    return res.status(400).send('Could not create export, missing data')\n  }\n\n  /**\n   * Exports a large dataset\n   * calls the exportLarge method on the agol model\n   * @param {objects} params - file export parameters\n   */\n  controller._exportLarge = function (params) {\n    var req = params.req\n    var res = params.res\n    var itemJson = params.itemJson\n    req.query.name = params.name\n\n    // set the geometry type so the exporter can do its thing for csv points (add x,y)\n    if (itemJson.data && itemJson.data && itemJson.data.info && itemJson.data.info.geometryType) {\n      req.query.geomType = itemJson.data[0].info.geometryType\n    }\n\n    // force export of large data\n    req.query.large = true\n\n    agol.exportFile(params, req.query, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (result && result.status && result.status === 'processing') {\n        // TODO refactor this\n        var tableKey = controller._createTableKey('agol', req.params)\n        agol.getCount(tableKey, {}, function (err, count) {\n          if (err) {\n            return res.status(500).send(err)\n          }\n          var code = 202\n\n          var response = {\n            status: 'processing',\n            processing_time: (Date.now() - result.retrieved_at) / 1000 || 0,\n            count: count\n          }\n\n          if (result.generating) {\n            response.generating = result.generating\n            // we received an error from the server\n            if (result.generating.error) {\n              code = 502\n            }\n          }\n          res.status(code).json(response)\n        })\n        return\n      }\n\n      if (req.query.url_only) {\n        // reuse this code...\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, req.params.format)\n\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?' + origUrl[1]\n            .replace(/url_only=true&|url_only=true|/, '')\n            .replace('format=' + req.params.format, '')\n            .replace('&format=' + req.params.format, '')\n\n        return res.json({url: newUrl})\n      }\n      res.contentType('text')\n      return res.sendFile(result)\n    })\n  }\n\n  /**\n   * Exports \"non-large\" data to a file format\n   * @param {objects} params - file export parameters\n   */\n  controller._exportToFormat = function (params) {\n    var req = params.req\n    var res = params.res\n\n    var format = req.params.format\n    var options = {\n      isFiltered: req.query.isFiltered,\n      name: params.name,\n      outSR: req.query.outSR\n    }\n\n    if (params.itemJson.metadata) {\n      options.metadata = params.itemJson.metadata\n    }\n\n    agol.exportFile(params, options, function (err, result) {\n      if (err) {\n        return res.status(err.code || 400).send(err)\n      }\n\n      if (req.query.url_only) {\n        var origUrl = req.originalUrl.split('?')\n        origUrl[0] = origUrl[0].replace(/json/, format)\n        var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n        newUrl += origUrl[1]\n          .replace(/url_only=true&|url_only=true|/, '')\n          .replace('format=' + format, '')\n          .replace('&format=' + format, '')\n\n        return res.json({url: newUrl})\n      }\n\n      res = controller._setHeaders(res, params.name, format)\n      if (result.substr(0, 4) === 'http') {\n        // Proxy to s3 urls allows us to not show the URL\n        return https.get(result, function (proxyRes) {\n          proxyRes.pipe(res)\n        })\n      } else {\n        res.sendFile(result)\n      }\n    })\n  }\n\n  /**\n   * Returns a file as either a URL or an actual file download\n   *\n   * @params {object} request object\n   * @params {object} response object\n   * @params {string} path - the path the file\n   * @params {string} name - the name of the file\n   * @private\n   */\n  controller._returnFile = function (req, res, path, name) {\n    var format = req.params.format\n    if (req.query.url_only) {\n      var origUrl = req.originalUrl.split('?')\n      origUrl[0] = origUrl[0].replace(/json/, format)\n      var newUrl = req.protocol + '://' + req.get('host') + origUrl[0] + '?'\n      newUrl += origUrl[1]\n        .replace(/url_only=true&|url_only=true|/, '')\n        .replace('format=' + format, '')\n        .replace('&format=' + format, '')\n\n      return res.json({url: newUrl})\n    }\n\n    // forces browsers to download\n    res = controller._setHeaders(res, name, format)\n\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      return https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    }\n\n    return res.sendFile(path)\n  }\n\n  /**\n   * Set file download headers for data exports\n   * adds the content-disposition and content-type bases on the file format\n   *\n   * @params {object} response object\n   * @params {string} name - the name of the file\n   * @params {string} format - the exported file format\n   * @returns {object} response\n   */\n  controller._setHeaders = function (res, name, format) {\n    res.setHeader('Content-disposition', 'attachment; filename=' + (encodeURIComponent(name) + '.' + format))\n    switch (format) {\n      case 'json':\n      case 'geojson':\n        res.contentType('application/json')\n        break\n      case 'kml':\n        res.contentType('application/vnd.google-earth.kml+xml')\n        break\n      case 'csv':\n        res.contentType('text/csv')\n        break\n      case 'zip':\n        res.contentType('application/octet-stream')\n        break\n    }\n    return res\n  }\n\n  /**\n   * Handles all requests for FeatureServices\n   */\n  controller.featureserver = function (req, res) {\n    // check for geohash route and redirect\n    if (req.params.method && req.params.method === 'geohash') {\n      controller.getGeohash(req, res)\n      return\n    }\n\n    var callback = req.query.callback\n    delete req.query.callback\n\n    // support POST requests; map body vals to the query\n    // (then all same as GET)\n    for (var k in req.body) {\n      if (req.body[k]) {\n        req.query[k] = req.body[k]\n      }\n    }\n\n    if (!req.params.layer) {\n      req.query.layer = 0\n    }\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n\n      // sort the req.query before we hash so we are consistent\n      var sorted_query = {}\n      _(req.query).keys().sort().each(function (key) {\n        if (key !== 'url_only' && key !== 'format') {\n          sorted_query[key] = req.query[key]\n        }\n      })\n      // build the file key as an MD5 hash that's a join on the paams and look for the file\n      var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n      var key = crypto.createHash('md5').update(toHash).digest('hex')\n      // Get the item\n\n      // set a really high limit so large datasets can be turned into feature services\n      req.query.limit = req.query.limit || req.query.resultRecordCount || 1000000000\n      req.query.offset = req.query.resultOffset || null\n      agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n        if (error) {\n          return res.status(error.code || 500).send(error.error || error)\n        }\n\n        // pass to the shared logic for FeatureService routing\n        delete req.query.geometry\n        delete req.query.where\n        controller.processFeatureServer(req, res, err, itemJson.data, callback)\n      })\n    })\n  }\n\n  /**\n   * Handles request for thubmnails\n   */\n  controller.thumbnail = function (req, res) {\n    var key, dir, layer\n\n    agol.find(req.params.id, function (err, data) {\n      if (err) {\n        return res.status(404).send(err)\n      }\n      layer = (req.params.layer || 0)\n\n      // check the image first and return if exists\n      key = ['agol', req.params.id, req.params.item, layer].join(':')\n      dir = '/thumbs'\n      req.query.width = parseInt(req.query.width, 0) || 150\n      req.query.height = parseInt(req.query.height, 0) || 150\n      req.query.f_base = dir + '/' + req.params.item + '_' + layer + '/' + req.params.item + '::' + req.query.width + '::' + req.query.height\n      var png = req.query.f_base + '.png'\n\n      agol.files.exists(null, png, function (exists) {\n        if (exists) {\n          return res.sendFile(png)\n        }\n\n        // if we have a layer then pass it along\n        if (req.params.layer) {\n          req.query.layer = req.params.layer\n        }\n\n        // sort the req.query before we hash so we are consistent\n        var sorted_query = {}\n        _(req.query).keys().sort().each(function (key) {\n          if (key !== 'url_only' && key !== 'format') {\n            sorted_query[key] = req.query[key]\n          }\n        })\n        // build the file key as an MD5 hash that's a join on the paams and look for the file\n        var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n        key = crypto.createHash('md5').update(toHash).digest('hex')\n\n        // Get the item\n        agol.getItemData(data.host, req.params.id, req.params.item, key, req.query, function (error, itemJson) {\n          if (error) {\n            return res.status(500).send(error)\n          }\n          if (itemJson.extent && itemJson.extent.length) {\n            req.query.extent = {\n              xmin: itemJson.extent[0][0],\n              ymin: itemJson.extent[0][1],\n              xmax: itemJson.extent[1][0],\n              ymax: itemJson.extent[1][1]\n            }\n          }\n\n          // generate a thumbnail\n          delete itemJson.data[0].info\n          agol.generateThumbnail(itemJson.data[0], req.params.item + '_' + req.params.layer, req.query, function (err, file) {\n            if (err) {\n              return res.status(500).send(err)\n            }\n\n            // send back image\n            res.sendFile(file)\n          })\n        })\n      })\n    })\n  }\n\n  /**\n   * renders the preview map view\n   */\n  controller.preview = function (req, res) {\n    agol.log('info', 'Render preview ' + JSON.stringify(req.params))\n    res.render(__dirname + '/../views/demo', { locals: { host: req.params.id, item: req.params.item } })\n  }\n\n  /**\n   * Tile request handler, responds to z/x/y tile requests\n   *\n   */\n  controller.tiles = function (req, res) {\n    var callback = req.query.callback\n    delete req.query.callback\n\n    var key\n    var layer = req.params.layer || 0\n\n    // if no format given default to png\n    if (!req.params.format) {\n      req.params.format = 'png'\n    }\n\n    // Get the tile and send the response to the client\n    var _send = function (err, data) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      req.params.name = (data && data[0]) ? data[0].name : null\n      req.params.key = req.params.item + '_' + layer\n      agol.tileGet(req.params, (data && data[0]) ? data[0] : {}, function (err, tile) {\n        if (err) {\n          return res.status(err.code || 500).send(err.message || 'Unknown error while creating the tile')\n        }\n\n        if (req.params.format === 'pbf') {\n          res.setHeader('content-encoding', 'deflate')\n        }\n\n        if (req.params.format === 'png' || req.params.format === 'pbf') {\n          return res.sendFile(tile)\n        }\n\n        if (callback) {\n          return res.send(callback + '(' + fs.readFileSync(JSON.parse(tile)) + ')')\n        }\n        return res.json(JSON.parse(fs.readFileSync(tile)))\n      })\n    }\n\n    // build the geometry from z,x,y\n    var bounds = merc.bbox(req.params.x, req.params.y, req.params.z, false, '4326')\n    req.query.geometry = {\n      xmin: bounds[0],\n      ymin: bounds[1],\n      xmax: bounds[2],\n      ymax: bounds[3],\n      spatialReference: { wkid: 4326 }\n    }\n\n    var _sendImmediate = function (file) {\n      if (req.params.format === 'pbf') {\n        res.setHeader('content-encoding', 'deflate')\n      }\n\n      if (req.params.format === 'png' || req.params.format === 'pbf') {\n        return res.sendFile(file)\n      }\n\n      if (callback) {\n        return res.send(callback + '(' + JSON.parse(fs.readFileSync(file)) + ')')\n      }\n\n      return res.json(JSON.parse(fs.readFileSync(file)))\n    }\n\n    key = [req.params.item, layer].join('_')\n    var file = agol.files.localDir + '/tiles/'\n    file += key + '/' + req.params.format\n    file += '/' + req.params.z + '/' + req.params.x + '/' + req.params.y + '.' + req.params.format\n\n    var jsonFile = file.replace(/png|pbf|utf/g, 'json')\n\n    // if the json file alreadty exists, dont hit the db, just send the data\n    if (fs.existsSync(jsonFile) && !fs.existsSync(file)) {\n      _send(null, fs.readFileSync(jsonFile))\n    } else if (!fs.existsSync(file)) {\n      agol.find(req.params.id, function (err, data) {\n        if (err) {\n          res.status(404).send(err)\n        } else {\n          // if we have a layer then pass it along\n          if (req.params.layer) {\n            req.query.layer = req.params.layer\n          }\n\n          // sort the req.query before we hash so we are consistent\n          var sorted_query = {}\n          _(req.query).keys().sort().each(function (key) {\n            if (key !== 'url_only' && key !== 'format') {\n              sorted_query[key] = req.query[key]\n            }\n          })\n          // build the file key as an MD5 hash that's a join on the paams and look for the file\n          var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n          var hash = crypto.createHash('md5').update(toHash).digest('hex')\n\n          var factor = 0.1\n          req.query.simplify = ((Math.abs(req.query.geometry.xmin - req.query.geometry.xmax)) / 256) * factor\n\n          // make sure we ignore the query limit of 2k\n          req.query.enforce_limit = false\n\n          // Get the item\n          agol.getItemData(data.host, req.params.id, req.params.item, hash, req.query, function (error, itemJson) {\n            if (error) {\n              if (itemJson && itemJson.type === 'Image Service' && req.params.format === 'png') {\n                agol.getImageServiceTile(req.params, function (err, newFile) {\n                  if (err) {\n                    return res.status(500).send(err)\n                  }\n                  _sendImmediate(newFile)\n                })\n              } else {\n                res.status(error.code || 500).send(error)\n              }\n            } else {\n              _send(error, itemJson.data)\n            }\n          })\n        }\n      })\n    } else {\n      _sendImmediate(file)\n    }\n  }\n\n  /**\n   * Forced a drop of the cache for an item and DELETEs all known files\n   * used for responding to DELETE calls.\n   */\n  controller.deleteItemData = function (req, res) {\n    req.query.forceDelete = true\n    controller.dropItem(req, res)\n  }\n\n  /**\n   * Request handler for returning the counts of currently queued workers\n   *\n   */\n  controller.getQueueCounts = function (req, res) {\n    agol.getQueueCounts(function (err, response) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      res.json(response)\n    })\n  }\n\n  /**\n  * Get the geohash for an item/layer\n  *\n  *\n  */\n  controller.getGeohash = function (req, res) {\n    // used for asking if we have the data already\n    var tableKey = controller._createTableKey('agol', req.params)\n\n    // Determine if we have the file first\n    // -------------------------------------\n    // sort the req.query before we hash so we are consistent\n    var sorted_query = {}\n    _(req.query).keys().sort().each(function (key) {\n      sorted_query[key] = req.query[key]\n    })\n\n    // build the file key as an MD5 hash that's a join on the paams and look for the file\n    var toHash = req.params.item + '_' + (req.params.layer || 0) + JSON.stringify(sorted_query)\n    var fileKey = crypto.createHash('md5').update(toHash).digest('hex')\n    var key = req.params.item + '_' + req.params.layer\n    var filePath = ['latest', 'files', key].join('/')\n    var fileName = fileKey + '.geohash.json'\n\n    // does it exist?\n    agol.files.exists(filePath, fileName, function (exists, path, fileInfo) {\n      agol.getInfo(tableKey, function (err, info) {\n        if (err) {\n          return res.status(500).send(err)\n        }\n        if (!info) {\n          // re-direct to findItemData since we need to cache the data\n          req.params.silent = true\n          controller.findItemData(req, res)\n\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n\n          return res.status(202).json({ status: 'processing' })\n\n        } else if (info && (info.status === 'processing' || info.geohashStatus === 'processing')) {\n          // if we have a file send it, else return processing\n          if (exists) {\n            // send back the geohash, but send fileInfo to set the expired header\n            return controller.returnGeohash(req, res, path, fileInfo)\n          }\n          return res.status(202).json({ status: 'processing' })\n\n        } else {\n          // need to know if the data are expired or not\n          var isExpired = (info.retrieved_at && fileInfo && fileInfo.LastModified) ?\n            (new Date(info.retrieved_at) > new Date(fileInfo.LastModified)) :\n            false\n\n          if (!exists) {\n            // doesnt exist; must create the new aggregation file\n            req.params.silent = false\n            controller.createGeohash(req, res, filePath, fileName)\n          } else if (exists && !isExpired) {\n            controller.returnGeohash(req, res, path)\n          } else {\n            // a file exists and its NOT expired...\n            controller.returnGeohash(req, res, path, fileInfo) // returns the file\n            // make we dont try to send a request response again (set silent: true)\n            req.params.silent = true\n            controller.createGeohash(req, res, filePath, fileName) // creates a new geohash.\n          }\n        }\n      })\n    })\n  }\n\n  controller.returnGeohash = function (req, res, path, info) {\n    res.contentType('application/json')\n    if (info && info.LastModified) {\n      res.set('X-Expired', info.LastModified)\n      res.set('Access-Control-Allow-Headers', 'X-Expired')\n      res.set('Access-Control-Expose-Headers', 'X-Expired')\n    }\n    if (path.substr(0, 4) === 'http') {\n      // Proxy to s3 urls allows us to not show the URL\n      https.get(path, function (proxyRes) {\n        proxyRes.pipe(res)\n      })\n    } else {\n      res.sendFile(path)\n    }\n  }\n\n  controller.createGeohash = function (req, res, filePath, fileName) {\n    agol.buildGeohash(req.params, filePath, fileName, req.query, function (err, agg) {\n      if (err) {\n        return res.status(500).send(err)\n      }\n      if (!req.params.silent) {\n        if (!agg) {\n          return res.status(202).json({ status: 'processing' })\n        } else {\n          return res.json(agg)\n        }\n      }\n    })\n  }\n\n  return controller\n\n}\n\nmodule.exports = Controller\n",
      "path": "controller/index.js",
      "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/controller/index.js#L13-L1103"
    },
    "name": "Controller",
    "kind": "module",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "Controller"
    ]
  },
  {
    "description": "Force a url to use https vs http",
    "tags": [
      {
        "title": "param",
        "description": "The url for the request\nreturns {string} url",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "url"
      },
      {
        "title": "name",
        "name": "forceHttps"
      },
      {
        "title": "kind",
        "kind": "function"
      }
    ],
    "loc": {
      "start": {
        "line": 1,
        "column": 0
      },
      "end": {
        "line": 5,
        "column": 3
      }
    },
    "context": {
      "loc": {
        "start": {
          "line": 6,
          "column": 0
        },
        "end": {
          "line": 13,
          "column": 0
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-agol/models/utils.js",
      "code": "var forceHttps = function (url) {\n  if (url && url.split('//').length > 1) {\n    url = url.split('//')[1].match(/^service/) ? url.replace('http:', 'https:') : url\n  }\n  return url\n}\n\nexports.forceHttps = forceHttps\n",
      "path": "models/utils.js",
      "github": "https://github.com/koopjs/koop-agol/blob/42457601cfebd44ee56db926cf008753cfbd2955/models/utils.js#L6-L13"
    },
    "params": [
      {
        "title": "param",
        "description": "The url for the request\nreturns {string} url",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "url"
      }
    ],
    "name": "forceHttps",
    "kind": "function",
    "members": {
      "instance": [],
      "static": []
    },
    "events": [],
    "path": [
      "forceHttps"
    ]
  }
]